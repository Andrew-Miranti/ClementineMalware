using System;
using System.Collections.Generic;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows;

namespace Clementine
{
    public sealed class Stars : ParallelPayload
    {
        private const int MAX_NEW_STARS = 20;
        private static readonly Random random = new Random();
        private List<Star> stars;
        private Graphics graphics;
        private IntPtr dc;

        public Stars() : base(10) {}

        private class Star // Thanks http://stackoverflow.com/questions/14385838/draw-on-screen-without-form
        {
            private const int Rad = 5, MaxSpeed = 20;
            private static readonly System.Drawing.Size size = new System.Drawing.Size(2 * Rad, 2 * Rad);
            public int X { get; private set; }
            public int Y { get; private set; }
            private int dx, dy;
            private Pen pen = new Pen(Color.White);

            public Star()
            {
                X = random.Next((int)SystemParameters.VirtualScreenLeft, (int)(SystemParameters.VirtualScreenLeft + SystemParameters.VirtualScreenWidth));
                Y = random.Next((int)SystemParameters.VirtualScreenTop, (int)(SystemParameters.VirtualScreenTop + SystemParameters.VirtualScreenHeight));
                dx = random.Next(-MaxSpeed, MaxSpeed);
                dy = random.Next(-MaxSpeed, MaxSpeed);
            }

            public void Advance()
            {
                X += dx;
                Y += dy;
            }

            public bool IsInBounds()
            {
                return X >= SystemParameters.VirtualScreenLeft && 
                       Y >= SystemParameters.VirtualScreenTop &&
                       X < SystemParameters.VirtualScreenLeft + SystemParameters.VirtualScreenWidth &&
                       Y < SystemParameters.VirtualScreenTop + SystemParameters.VirtualScreenHeight;
            }

            public void Draw(Graphics g)
            {
                g.DrawEllipse(pen, new Rectangle(new System.Drawing.Point(X - Rad, Y - Rad), size));
            }

        }

        protected override void StartupTasks()
        {
            stars = new List<Star>();
            dc = GetDC(IntPtr.Zero);
            graphics = Graphics.FromHdc(dc);
        }

        protected override void ShutdownTasks()
        {
            stars.Clear();
            graphics.Dispose();
            graphics = null;
            ReleaseDC(IntPtr.Zero, dc);
            dc = IntPtr.Zero;
        }

        protected override void Payload()
        {
            for (int i = 0; i < random.Next(MAX_NEW_STARS); i++)
            {
                stars.Add(new Star());
            }

            foreach (var star in stars)
            {
                star.Advance();
                star.Draw(graphics);
            }

            for (int i = 0; i < stars.Count; i++)
            {
                if (!stars[i].IsInBounds())
                {
                    stars.RemoveAt(i);
                    i--;
                }
            }
        }

        [DllImport("user32.dll")]
        private static extern IntPtr GetDC(IntPtr hwnd);

        [DllImport("user32.dll")]
        private static extern void ReleaseDC(IntPtr hwnd, IntPtr dc);
    }
}
