using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace ClementineBasicServer
{
    class ClementineServer
    {
        private const int PORT = 4398;
        private readonly List<ClementineConnection> connections = new List<ClementineConnection>();
        private readonly Dictionary<IPAddress, ClementineStatus> statusMap = new Dictionary<IPAddress, ClementineStatus>();
        private readonly object statusLock = new object();

        private Thread listenerThread;

        private readonly TcpListener listener = TcpListener.Create(PORT);

        private bool done = true;
        public bool Done
        {
            get
            {
                lock (statusLock)
                {
                    return done;
                }
            }

            set
            {
                lock (statusLock)
                {
                    done = value;
                }
            }
        }

        public void Start()
        {
            Console.WriteLine("Start called");
            if (!Done)
            {
                Console.WriteLine("Already started... returning");
                return;
            }
            Done = false;
            lock (statusLock)
            {
                listener.Start();
                listenerThread = new Thread(this.Listen);
                listenerThread.Start();
            }
        }

        private void CheckForFinished()
        {
            for (int i = 0; i < connections.Count; i++)
            {
                if (connections[i].Done)
                {
                    connections.RemoveAt(i);
                    i--;
                }
            }
        }

        private static IPAddress getIPFromClient(TcpClient client)
        {
            return ((IPEndPoint)client.Client.RemoteEndPoint).Address;
        }

        private void Listen()
        {
            Console.WriteLine("Listener called");
            while (!Done)
            {
                Console.WriteLine("in Loop");
                while (!Done && !listener.Pending())
                {
                    CheckForFinished();
                    Thread.Sleep(100); // Worst.  Code.  Ever.
                }
                Console.WriteLine("INCOMING");
                if (Done)
                {
                    return;
                }
                Console.WriteLine("About to accept");

                var client = listener.AcceptTcpClient();
                Console.WriteLine("Accepted");
                if (client != null)
                {
                    var address = getIPFromClient(client);
                    lock (statusLock)
                    {
                        if (!statusMap.ContainsKey(address))
                        {
                            statusMap.Add(address, new ClementineStatus());
                            Console.WriteLine("Generated");
                        }
                        else
                        {
                            Console.WriteLine("Exisiting Status found");
                        }

                        Console.WriteLine("Connected to Clementine at " + address.ToString());
                        connections.Add(new ClementineConnection(client, statusMap[address]));
                    }
                }
            }
        }

        public List<IPAddress> GetKnownClients()
        {
            lock(statusLock)
            {
                return new List<IPAddress>(statusMap.Keys);
            }
        }

        public ClementineStatus GetStatus(IPAddress addr)
        {
            lock(statusLock)
            {
                if (!statusMap.ContainsKey(addr))
                {
                    statusMap.Add(addr, new ClementineStatus());
                }
                return statusMap[addr];
            }
        }

        public void Stop()
        {
            if (Done)
            {
                return;
            }
            Done = true;
            listener.Stop();
            listenerThread.Join();

            foreach (var connection in connections)
            {
                connection.Done = true;
                connection.ConnectionThread.Join();
            }

            connections.Clear();
            listenerThread = null;
        }
    }
}
